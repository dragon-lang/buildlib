/**
Make Library

Rules are made up of targets, dependencies and an action.
The "target files" are generated by the corresponding action.

TODO:
- normalize target names for matching (i.e. "a" should match "./a")

*/
module build.make;

import std.typecons : Flag, Yes, No;
import std.algorithm : max;
import std.format : format;
import std.file : exists;
import std.datetime : SysTime;

import build.log;

/**
Load environment variables into the given `varMap`.
*/
void loadEnvVars(string*[string] varMap)
{
    import std.process : environment;

    foreach (pair; environment.toAA.byKeyValue)
    {
        auto envAddr = varMap.get(pair.key, null);
        if (envAddr)
        {
            logf("Set from environment variable %s=%s", pair.key, pair.value);
            *envAddr = pair.value;
        }
        else
        {
            verbosef("ignoring env '%s'", pair.key);
        }
    }
}
/**
Load command line arguments of the form 'FOO=BAR' into the given `varMap`.
Returns: the given `args` with variable sets filtered out.
*/
string[] loadCmdLine(string*[string] varMap, string[] args)
{
    import std.string : indexOf;
    import build.error : fatal;

    auto newArgs = new string[args.length];
    auto newArgsLength = 0;
    newArgs[newArgsLength++] = args[0];
    for (size_t i = 1; i < args.length; i++)
    {
        const arg = args[i];
        auto equalIndex = arg.indexOf('=');
        if (equalIndex < 0)
        {
            newArgs[newArgsLength++] = arg;
            continue;
        }
        const key = arg[0 .. equalIndex];
        const value = arg[equalIndex + 1 .. $];
        // do not set the environment variable.
        // if that's what the caller wanted they could have set the
        // environment variable instead, i.e.
        //     FOO=foo build
        // rather than
        //     build FOO=foo
        auto envAddr = varMap.get(key, null);
        if (envAddr is null)
            throw fatal("variable '%s' does not exist to set", key);
        logf("Set from command line %s=%s", key, value);
        *envAddr = value;
    }
    return newArgs[0 .. newArgsLength];
}

struct FileTime
{
    enum Type
    {
        doesNotExist,
        isDir,
        haveSysTime,
    }
    static FileTime makeDoesNotExist() { return FileTime(Type.doesNotExist); }
    static FileTime makeIsDir() { return FileTime(Type.isDir); }
    static FileTime from(SysTime sysTime) { return FileTime(Type.haveSysTime, sysTime); }

    Type type;
    private SysTime _sysTime;

    auto sysTime() const
    in { assert(type == Type.haveSysTime); } body
    { return _sysTime; }
}
FileTime getFileTime(string path)
{
    version (Windows)
    {
        import std.file : timeLastModified;
        import build.file : getFileAttributes;

        // TODO: does windows have a single function that can get time last modified and
        //       whether it's a directory?
        auto attr = getFileAttributes(path);
        if (!attr.exists)
            return FileTime.makeDoesNotExist;
        if (attr.isDir)
            return FileTime.makeIsDir;
        return FileTime.from(path.timeLastModified);
    }
    else
    {
        import core.stdc.errno : errno, ENOENT;
        import core.sys.posix.sys.stat : stat_t, stat;
        import std.internal.cstring : tempCString;
        import std.datetime.systime : unixTimeToStdTime;
        import std.file : FileException, attrIsDir;

        stat_t statbuf = void;
        int result = stat(path.tempCString!char(), &statbuf);
        if(result != 0)
        {
            if (errno == ENOENT)
                return FileTime.makeDoesNotExist;
            throw new FileException(path, format("stat function failed (e=%d)", errno));
        }
        if (attrIsDir(statbuf.st_mode))
            return FileTime.makeIsDir;
        return FileTime.from(SysTime(unixTimeToStdTime(statbuf.st_mtime)));
    }
}


class MakeException : Exception
{
    this(string msg)
    {
        super(msg);
    }
}

class Rule
{
    private enum State : ubyte
    {
        initial,       // nothing known about rule yet
        buildingDeps,  // building dependencies
        alreadyBuilt,  // targets were already built, use targetInfos[i].dependResult
        executing,     // executing the rule
        newlyBuilt,    // the rule was executed so all targets are newly built
    }

    private string[] _targets;
    /**
    Depencies are grouped by names. This allows them to be referenced in actions by their name.
    */
    private string[][string] dependGroups;

    private void delegate(Rule rule) action;

    private State state;

    private static struct TargetInfo
    {
        bool isPhony;
        DependResult dependResult;
    }
    private TargetInfo[] _targetInfos;

    Rule copy() const
    {
        auto newRule = new Rule();
        newRule._targets = _targets.dup;
        newRule.dependGroups = cast(typeof(newRule.dependGroups))dependGroups.dup;
        newRule.action = action;
        newRule._targetInfos = _targetInfos.dup;
        return newRule;
    }
    const(string)[] targets() const { return _targets; }
    string target() const
    {
        if (_targets.length != 1)
            throw new MakeException(format("cannot call target on a rule with %s targets", _targets.length));
        return _targets[0];
    }
    string depend() const
    {
        if (dependGroups.length != 1)
            throw new MakeException(format("cannot call depend on rule with %s groups", dependGroups.length));
        auto range = dependGroups.byValue();
        assert(!range.empty, "code bug");
        auto group = range.front;
        if (group.length != 1)
            throw new MakeException(format("cannot call depend on rule with 1 group that has %s depencies", group.length));
        return group[0];
    }
    string[] dependGroup(string name)
    {
        // TODO: A group should be allowed to be empty
        auto group = dependGroups.get(name, null);
        if (group is null)
            throw new MakeException(format("'%s' is not a group of this rule", name));
        return group;
    }
    auto targetInfos() const
    {
        static struct Range
        {
            const(Rule) rule;
            size_t next;
            this(const(Rule) rule)
            {
                this.rule = rule;
                this.next = 0;
            }
            bool empty() const { return this.next >= rule.targets.length; }
            auto front() { return const RuleAndTarget(rule, next); }
            void popFront() { this.next++; }
        }
        return Range(this);
    }
}

private struct RuleAdder
{
    Make* make;
    Rule rule;
    this(Make* make, Rule rule)
    {
        this.make = make;
        this.rule = rule;
    }
    private RuleAdder* target(string name, Flag!"phony" phony)
    {
        auto existing = make.ruleTargetMap.get(name, RuleAndTarget.nullValue);
        if (!existing.isNull)
            throw new MakeException(format("multiple rules with the same target '%s'", name));
        make.ruleTargetMap[name] = RuleAndTarget(rule, rule._targets.length);
        rule._targets ~= name;
        rule._targetInfos ~= Rule.TargetInfo(phony, DependResult.min);
        return &this;
    }
    RuleAdder* target(string name)
    {
        return target(name, No.phony);
    }
    RuleAdder* target(const string[] names)
    {
        foreach (name; names)
        {
            target(name, No.phony);
        }
        return &this;
    }
    RuleAdder* phonyTarget(string name)
    {
        return target(name, Yes.phony);
    }
    RuleAdder* depend(string dep)
    {
        rule.dependGroups[null] ~= dep;
        return &this;
    }
    RuleAdder* depend(const string[] deps)
    {
        rule.dependGroups[null] ~= deps;
        return &this;
    }
    RuleAdder* dependGroup(string groupName, string dep)
    {
        rule.dependGroups[groupName] ~= dep;
        return &this;
    }
    RuleAdder* dependGroup(string groupName, const string[] deps)
    {
        rule.dependGroups[groupName] ~= deps;
        return &this;
    }
    RuleAdder* action(void delegate(Rule) a)
    {
        if (rule.action !is null)
            throw new MakeException("the same rule was given multiple actions");
        rule.action = a;
        return &this;
    }
}

struct DependResult
{
    static DependResult alreadyBuilt(SysTime time) { return DependResult(State.alreadyBuilt, time); }
    static DependResult newlyBuilt() { return DependResult(State.newlyBuilt); }
    static DependResult min() { return alreadyBuilt(SysTime.min); }
    static DependResult max() { return newlyBuilt; }
    private enum State
    {
        alreadyBuilt,
        newlyBuilt,
    }
    private State state;
    private SysTime alreadyBuiltTime;
    int opCmp(ref const DependResult right) const
    {
        if (isNewlyBuilt)
            return right.isNewlyBuilt ? 0 : 1;
        return this.alreadyBuiltTime.opCmp(right.alreadyBuiltTime);
    }
    bool isNewlyBuilt() const { return state == State.newlyBuilt; }
    void setNewlyBuilt() { this.state = State.newlyBuilt; }
    void updateNewest(SysTime time)
    {
        if (isNewlyBuilt)
        {
            //verbosef("DEPEND RESULT ALREADY AT NEWLY BUILT");
        }
        else if (time > alreadyBuiltTime)
        {
            //verbosef("DEPEND RESULT NEW TIME '%s'", time);
            alreadyBuiltTime = time;
        }
        else
        {
            //verbosef("DEPEND RESULT %s ALREADY NEWER THAN %s", alreadyBuiltTime, time);
        }
    }
    void updateNewest(ref const DependResult right)
    {
        if (right.isNewlyBuilt)
        {
            //verbosef("DEPEND RESULT SET TO NEWLY BUILT!");
            this.state = State.newlyBuilt;
        }
        else
        {
            updateNewest(right.alreadyBuiltTime);
        }
    }
    void toString(scope void delegate(const(char)[]) sink) const
    {
        import std.format : formattedWrite;

        if (state == State.newlyBuilt)
            sink("NEW");
        else
            formattedWrite(sink, "%s", alreadyBuiltTime);
    }
}

private struct RuleAndTarget
{
    static RuleAndTarget nullValue() { return RuleAndTarget(null); }
    bool isNull() const { return rule is null; }

    Rule rule;
    size_t targetIndex;
    auto name() const { return rule.targets[targetIndex]; }
    bool isPhony() const { return rule._targetInfos[targetIndex].isPhony; }
    auto targetInfo() const { return rule._targetInfos[targetIndex]; }
    void setDependResult(ref const DependResult result)
    {
        rule._targetInfos[targetIndex].dependResult = result;
    }
    void toString(scope void delegate(const(char)[]) sink) const
    {
        sink("RuleAndTarget(TODO: implement ToString)");
    }
}

struct Make
{
    import std.array : Appender;

    private Appender!(Rule[]) rules; // list of all rules
    private RuleAndTarget[string] ruleTargetMap; // map from rule targets to rules

    // Dependencies that are added to all rules
    private string[] globalDepends;
    private bool globalDependsBuilt; // just a small optimization


    /** Do not call this function to add rules */
    const(Rule)[] getRules() const { return rules.data; }

    void resetBuildState()
    {
        foreach (rule; rules.data)
        {
            rule.state = Rule.State.initial;
        }
    }
    Make copy() const
    {
        auto newCopy = Make();
        foreach (rule; rules.data)
        {
            newCopy.addRule(rule.copy());
        }
        newCopy.globalDepends = globalDepends.dup;
        return newCopy;
    }
    auto addGlobalDepend(string depend)
    {
        globalDepends ~= depend;
    }
    auto addRule()
    {
        auto rule = new Rule();
        rules.put(rule);
        return RuleAdder(&this, rule);
    }
    private void addRule(Rule rule)
    {
        if (rule._targets.length == 0)
            throw new MakeException("every rule must have at least 1 target");
        rules.put(rule);
        foreach (i, target; rule._targets)
        {
            auto existing = ruleTargetMap.get(target, RuleAndTarget.nullValue);
            if (!existing.isNull)
                throw new MakeException(format("multiple rules with the same target '%s'", target));
            ruleTargetMap[target] = RuleAndTarget(rule, i);
        }
    }
    void build(string[] targets, DependResult* newestParentDep)
    {
        foreach (target; targets)
        {
            build(target, newestParentDep);
        }
    }
    /**
    Algorithm: build FOO

    - Check if there is a rule for FOO.
    - If no rule.
       - if exists as a file, done, return "FOO already built"
       - else assert error "no rule for target FOO"
    - Else, there is a rule.
       - build all dependencies
       - if no action, done (short circuit)
       - if any dependency was built, execute rule action, return "built FOO"
       - else if any dependency timestamp is newer than any target, execute rule action, return "built FOO"
           * note: there could be implied dependencies (like on the file that configured the build)
       - else return "FOO already built"
    */
    void build(string targetString, DependResult* newestParentDep)
    {
        auto ruleTarget = ruleTargetMap.get(targetString, RuleAndTarget.nullValue);
        if (ruleTarget.isNull)
        {
            auto time = getFileTime(targetString);
            final switch (time.type)
            {
            case FileTime.Type.doesNotExist:
                throw new MakeException(format("target '%s' does not exist and has no matching rule", targetString));
            case FileTime.Type.isDir:
                break; // don't update time, existence of directories is all that's needed
            case FileTime.Type.haveSysTime:
                //logf("updateNewestTime from '%s' %s", targetString, time);
                newestParentDep.updateNewest(time.sysTime);
            }
            return;
        }
        auto rule = ruleTarget.rule;
        final switch (rule.state)
        {
        case Rule.State.initial: break;
        case Rule.State.buildingDeps:
            throw new MakeException(format(
                "detected circular reference involving target '%s' (building deps) (todo: print chain)", targetString));
        case Rule.State.alreadyBuilt:
            if (newestParentDep !is null)
                newestParentDep.updateNewest(ruleTarget.targetInfo.dependResult);
            return;
        case Rule.State.executing:
            throw new MakeException(format(
                "detected circular reference involving target '%s' (executing) (todo: print chain)", targetString));
        case Rule.State.newlyBuilt:
            if (newestParentDep !is null)
                newestParentDep.setNewlyBuilt();
            return;
        }

        rule.state = Rule.State.buildingDeps;
        auto newestChildDep = DependResult.min;
        if (!globalDependsBuilt && globalDepends.length > 0)
        {
            verbosef("building global depends...");
            foreach (depend; globalDepends)
            {
                build(depend, &newestChildDep);
            }
            globalDependsBuilt = true;
        }
        if (rule.dependGroups.length > 0)
        {
            verbosef("building deps for '%s'...", targetString);
            foreach (pair; rule.dependGroups.byKeyValue)
            {
                build(pair.value, &newestChildDep);
            }
        }
        assert(rule.state == Rule.State.buildingDeps, "code bug");
        rule.state = Rule.State.executing;
        if (newestChildDep.isNewlyBuilt)
        {
            verbosef("executing rule for '%s' because one or more deps are newly built", targetString);
            executeRule(rule);
            if (newestParentDep !is null)
                *newestParentDep = DependResult.newlyBuilt;
            return;
        }
        // always build if it's a phony target
        if (ruleTarget.targetInfo.isPhony)
        {
            verbosef("executing rule for '%s' because it is a phony target", targetString);
            executeRule(rule);
            if (newestParentDep !is null)
                *newestParentDep = DependResult.newlyBuilt;
            return;
        }
        foreach (i, checkTarget; rule.targets)
        {
            if (rule._targetInfos[i].isPhony)
                continue;

            auto targetTime = getFileTime(checkTarget);
            final switch (targetTime.type)
            {
            case FileTime.Type.doesNotExist:
                verbosef("executing rule for '%s' because target '%s' does not exist", targetString, checkTarget);
                executeRule(rule);
                if (newestParentDep !is null)
                    *newestParentDep = DependResult.newlyBuilt;
                return;
            case FileTime.Type.isDir:
                break; // don't update time, existence of directories is all that's needed
            case FileTime.Type.haveSysTime:
                rule._targetInfos[i].dependResult = DependResult.alreadyBuilt(targetTime.sysTime);
                if (rule._targetInfos[i].dependResult < newestChildDep)
                {
                    verbosef("executing rule for '%s' because target '%s' is older than a dependency", targetString, checkTarget);
                    verbosef("%s < %s", rule._targetInfos[i].dependResult, newestChildDep);
                    executeRule(rule);
                    if (newestParentDep !is null)
                        *newestParentDep = DependResult.newlyBuilt;
                    return;
                }
                verbosef("target '%s' is up-to-date (%s)", checkTarget, rule._targetInfos[i].dependResult);
                if (newestParentDep !is null)
                    newestParentDep.updateNewest(rule._targetInfos[i].dependResult);
            }
        }
        assert(rule.state == Rule.State.executing, "code bug");
        rule.state = Rule.State.alreadyBuilt;
    }
    private void executeRule(Rule rule)
    {
        assert(rule.state == Rule.State.executing, "code bug");

        // TODO: should we remove the target files?

        if (rule.action)
        {
            // TODO: catch exceptions?
            rule.action(rule);
        }
        foreach (i, target; rule.targets)
        {
            if (!rule._targetInfos[i].isPhony)
            {
                if (!exists(target))
                    throw new MakeException(format("rule didn't generate target '%s'", target));
            }
        }
        assert(rule.state == Rule.State.executing, "code bug");
        rule.state = Rule.State.newlyBuilt;
    }
    void dump()
    {
        foreach (ref rule; rules.data)
        {
            import std.stdio;
            if (rule.targets.length == 1)
            {
                writefln("1 target '%s'", rule.targets[0]);
            }
            else
            {
                writefln("%s targets:", rule.targets.length);
                foreach (target; rule.targets)
                    writefln("  %s", target);
            }
            foreach (pair; rule.dependGroups.byKeyValue)
            {
                foreach (dep; pair.value)
                {
                    if (pair.key.length == 0)
                        writefln("    <no-group>: %s", dep);
                    else
                        writefln("    %s: %s", pair.key, dep);
                }
            }
        }
    }

    /**
    Test the build by building each rule independently in isolation.
    Params:
        testDir = a directory that can be used to copy files to for the build
    */
    void testBuild(string testDir, string[] skipTargets)
    {
        import std.algorithm : canFind;
        import std.file : mkdir;
        import std.stdio;
        import build.proc : execute;

        // build every target from a clean state, but only build it declared dependencies
      RuleLoop:
        foreach (ruleIndex, rule; rules.data)
        {
           assert(rule.targets.length > 0, "code bug: have a rule with no targets");
           foreach (skipTarget; skipTargets)
               if (rule.targets.canFind(skipTarget))
                   continue RuleLoop;

           writefln("Testing rule %s of %s...", ruleIndex + 1, rules.data.length);
           foreach (target; rule.targets)
           {
               writefln(" target '%s'", target);
           }
           writeln("--------------------------------------------------------------------------------");
           execute(["rm", "-rf", testDir]);
           mkdir(testDir);
           deployDependsForTest(testDir, skipTargets, globalDepends);
           deployRuleForTest(testDir, skipTargets, rule);
        }
    }
    private void deployRuleForTest(string testDir, string[] skipTargets, Rule rule)
    {
        import std.range : chain;

        foreach (pair; rule.dependGroups.byKeyValue)
        {
            deployDependsForTest(testDir, skipTargets, pair.value);
        }
    }
    private void deployDependsForTest(string testDir, string[] skipTargets, string[] depends)
    {
        foreach (depend; depends)
        {
            auto ruleTarget = ruleTargetMap.get(depend, RuleAndTarget.nullValue);
            if (ruleTarget.isNull)
            {
                auto time = getFileTime(depend);
                final switch (time.type)
                {
                case FileTime.Type.doesNotExist:
                    throw new MakeException(format("dependency '%s' does not exist and has no matching rule", depend));
                case FileTime.Type.isDir:
                    break; // don't update time, existence of directories is all that's needed
                case FileTime.Type.haveSysTime:
                    //logf("updateNewestTime from '%s' %s", targetString, time);
                    deployFileForTest(testDir, depend);
                    break;
                }
                return;
            }
            deployRuleForTest(testDir, skipTargets, ruleTarget.rule);
        }
    }
    private void deployFileForTest(string testDir, string file)
    {
        logf("copy '%s' to '%s'", file, testDir);
    }
}

unittest
{
    auto make = Make("deps");
    make.rule
        .target("a")
        .action("echo hello > a")
        ;
    make.dump();
    make.build("a");
}
